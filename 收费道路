/*********
来源	POJ 3411 搜索回溯 陈林 2012春季算法实验班
描述
一个由m条道路组成的网络连接着N个城市（编号为1到N）。不同城市之间可能有多条道路。其中有一些道路是收费的。对于一条从城市ai到城市bi的收费道路i，有两种方式付款： 

1、预先付款：在城市ci（ci可能和ai相同，也可能不同。也就是说，在通过从ai到bi的道路i之前，曾经经过城市ci，在那里预先把这段路费付清） 

2、之后付款：在城市bi（即通过这段道路i之后，在目的城市bi进行付款） 

第1种情况要付Pi元，第2种情况要付Ri元。其中Pi≤Ri。 

写一个程序寻找最低花费从城市1到城市N的路线。
关于输入
输入的第1行包含整数N和m。接下来的m行每行都表示1条道路，给出了道路的5个值，ai，bi，ci，Pi，Ri (1 ≤ i ≤ m)，5个整数之间用一个或多个空格隔开。所有的值都是整数，1 ≤ m, N ≤ 10, 0 ≤ Pi , Ri ≤ 100, Pi ≤ Ri (1 ≤ i ≤ m)。
关于输出
输出只有1行，即从城市1到城市N最少的费用。如果从城市1无法到达城市N，输出impossible。
例子输入
4 5

1 2 1 10 10

2 3 1 30 50

3 4 3 80 80

2 1 2 10 10

1 3 2 10 50
例子输出
110
提示
深度优先搜索
**********/
#include <iostream>
#include <iomanip>
#include <cmath>
#include <cstring>
#include <algorithm>
using namespace std;
struct graph{
    int cost;
    int pcost;
};
bool flag[15]={false};
int mem[15][15]={0};
graph arc[15][15][15];
int MIN=0x7fffffff;
int N,m;
void dfs(int pos,int exp){
    if(pos==N){
        if(exp<MIN){
            MIN=exp;
        }
        return;
    }
    for(int i=1;i<=N;++i){
        if(i==pos)continue;
        int l=0;
        for(l=1;l<=N;++l){
            if(arc[pos][i][l].cost>0)break;
        }
        if(l==N+1)continue;
        int tmp1=0,tmp2=0;
        int MAX=0x7fffffff;
        for(int k=1;k<=N;++k){
            if(arc[pos][i][k].pcost>0 && flag[k]==true){
                if(arc[pos][i][k].pcost<MAX){
                MAX=arc[pos][i][k].pcost;
                tmp1=k;
                tmp2=1;
                }
            }else if(arc[pos][i][k].cost>0 && flag[k]==false){
                if(arc[pos][i][k].cost<MAX){
                MAX=arc[pos][i][k].cost;
                tmp1=k;
                tmp2=0;
                }
            }
        }
        //cout<<MAX<<endl;
        if(tmp1==0)continue;
        if(tmp2==0 && mem[pos][i]<=N){
            flag[i]=true;
            mem[pos][i]++;
        dfs(i,exp+arc[pos][i][tmp1].cost);
            mem[pos][i]--;
            int j=1;
            for(j=1;j<=N;++j){
                if(mem[j][i]>0)break;
            }
            if(i!=1 && j==N+1)flag[i]=false;
        }
        else if(tmp2==1 && mem[pos][i]<=N){
            flag[i]=true;
            mem[pos][i]++;
            dfs(i,exp+arc[pos][i][tmp1].pcost);
            mem[pos][i]--;
            int j=1;
            for(j=1;j<=N;++j){
                if(mem[j][i]>0)break;
            }
            if(i!=1 && j==N+1)flag[i]=false;
        }
    }
}
int main(){
    cin>>N>>m;
    memset(arc,-1,sizeof(arc));
    for(int i=0;i<m;++i){
        int a,b,c,P,R;
        cin>>a>>b>>c>>P>>R;
        if(arc[a][b][c].cost==-1 || R<arc[a][b][c].cost){
            arc[a][b][c].cost=R;
        }
        if(arc[a][b][c].pcost==-1 || P<arc[a][b][c].pcost){
            arc[a][b][c].pcost=P;
        }
    }
    dfs(1,0);
    if(MIN==0x7fffffff){
        cout<<"impossible";
        return 0;
    }
    cout<<MIN;
    return 0;
}
