/**********8
来源	Japan 2004 Domestic
描述
有一间长方形的房子，地上铺了红色、黑色两种颜色的正方形瓷砖。你站在其中一块黑色的瓷砖上，只能向相邻的四块瓷砖中的黑色瓷砖移动。请写一个程序，计算你总共能够到达多少块黑色的瓷砖。
关于输入
包括多个数据集合。每个数据集合的第一行是两个整数W和H，分别表示x方向和y方向瓷砖的数量。W和H都不超过20。在接下来的H行中，每行包括W个字符。每个字符表示一块瓷砖的颜色，规则如下 
‘.’：黑色的瓷砖 
‘#’：红色的瓷砖 
‘@’：黑色的瓷砖，并且你站在这块瓷砖上。该字符在每个数据集合中仅出现一次 
当在一行中读入的是两个零时，表示输入结束。
关于输出
对每个数据集合，分别输出一行，显示你从初始位置出发能到达的瓷砖数(记数时包括初始位置的瓷砖)。
例子输入
6 9

....#.

.....#

......

......

......

......

......

#@...#

.#..#.

11 9

.#.........

.#.#######.

.#.#.....#.

.#.#.###.#.

.#.#..@#.#.

.#.#####.#.

.#.......#.

.#########.

...........

11 6

..#..#..#..

..#..#..#..

..#..#..###

..#..#..#@.

..#..#..#..

..#..#..#..

7 7

..#.#..

..#.#..

###.###

...@...

###.###

..#.#..

..#.#..

0 0
例子输出
45

59

6

13
**********/
#include <iostream>
#include <iomanip>
#include <cmath>
#include <cstring>
#include <algorithm>
using namespace std;
int W,H,cnt=0;
char str[25][25];
bool flag[25][25]={false};
int visit(int p,int q){
    flag[p][q]=true;
    cnt++;
    if(p>0 && flag[p-1][q]==false && str[p-1][q]=='.')visit(p-1,q);
    if(p<H-1 && flag[p+1][q]==false && str[p+1][q]=='.')visit(p+1,q);
    if(q>0 && flag[p][q-1]==false && str[p][q-1]=='.')visit(p,q-1);
    if(q<W-1 && flag[p][q+1]==false && str[p][q+1]=='.')visit(p,q+1);
    return 0;
}
int main(){
    while(true){
        cin>>W>>H;
        if(W==0 && H==0)break;
        int p=0,q=0;
        for(int i=0;i<H;++i){
            for(int j=0;j<W;++j){
                cin>>str[i][j];
                if(str[i][j]=='@'){
                    p=i;
                    q=j;
                }
            }
        }
        cnt=0;
        memset(flag,0,sizeof(flag));
        visit(p,q);
        cout<<cnt<<endl;
    }
    return 0;
}
