/************
描述
计算两个矩阵的乘法。n*m阶的矩阵A乘以m*k阶的矩阵B得到的矩阵C是n*k阶的，且C[i][j] = A[i][0]*B[0][j] + A[i][1]*B[1][j] + …… +A[i][m-1]*B[m-1][j](C[i][j]表示C矩阵中第i行第j列元素)
关于输入
首先输入G，即测试数据的组数 
每组测试数据输入： 
第一行为n, m, k，表示A矩阵是n行m列，B矩阵是m行k列，n, m, k均小于100 
然后先后输入A和B两个矩阵，A矩阵n行m列，B矩阵m行k列，矩阵中每个元素不会大于10000 
关于输出
针对每组数据，输出n行k列的C矩阵
例子输入
1

3 2 3

1 1

1 1

1 1

1 1 1

1 1 1
例子输出
2 2 2

2 2 2

2 2 2
提示
注意每行最后一个数后边的空格不要输出
**********/
#include <iostream>
#include <iomanip>
#include <cmath>
#include <cstring>
#include <algorithm>
using namespace std;
int main(){
    int G;
    cin>>G;
    for(int i=0;i<G;++i){
        int n,m,k;
        cin>>n>>m>>k;
        int **p1=(int **)malloc(sizeof(int *)*n);
        for(int i=0;i<n;++i){
            *(p1+i)=(int *)malloc(sizeof(int)*m);
        }
        int **p2=(int **)malloc(sizeof(int *)*m);
        for(int i=0;i<m;++i){
            *(p2+i)=(int *)malloc(sizeof(int)*k);
        }
        int **p3=(int **)malloc(sizeof(int *)*n);
        for(int i=0;i<n;++i){
            *(p3+i)=(int *)malloc(sizeof(int)*k);
        }
        for(int i=0;i<n;++i){
            for(int j=0;j<m;++j){
                cin>>*(p1[i]+j);
            }
        }
        for(int i=0;i<m;++i){
            for(int j=0;j<k;++j){
                cin>>*(p2[i]+j);
            }
        }
        for(int i=0;i<n;++i){
            for(int j=0;j<k;++j){
                *(p3[i]+j)=0;
            }
        }
        for(int i=0;i<n;++i){
            for(int j=0;j<k;++j){
                for(int u=0;u<m;++u){
                    *(p3[i]+j)+=(*(p1[i]+u))*(*(p2[u]+j));
                }
            }
        }
        for(int i=0;i<n;++i){
            for(int j=0;j<k-1;++j){
                cout<<*(p3[i]+j)<<' ';
            }
            cout<<*(p3[i]+k-1)<<endl;
        }
    }
    return 0;
}
