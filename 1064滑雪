/**********
描述
Michael喜欢滑雪这并不奇怪， 因为滑雪的确很刺激。可是为了获得速度，滑的区域必须向下倾斜，而且当你滑到坡底，你不得不再次走上坡或者等待升降机来载你。Michael想知道载一个区域中最长的滑坡。区域由一个二维数组给出。数组的每个数字代表点的高度。下面是一个例子 


1 2 3 4 5 
16 17 18 19 6 
15 24 25 20 7 
14 23 22 21 8 
13 12 11 10 9 

一个人可以从某个点滑向上下左右相邻四个点之一，当且仅当高度减小。在上面的例子中，一条可滑行的滑坡为24-17-16-1。当然25-24-23-...-3-2-1更长。事实上，这是最长的一条。
关于输入
输入的第一行表示区域的行数R和列数C(1 <= R,C <= 100)。下面是R行，每行有C个整数，代表高度h，0<=h<=10000。
关于输出
输出最长区域的长度。
********/
#include <iostream>
#include <iomanip>
#include <cmath>
#include <algorithm>
#include <cstdio>
#include <cstring>
#include <string>
#include <sstream>
#include <ctime>
#define MAX 0x7fffffff
using namespace std;
int arr[105][105];
int save[105][105]={0};
int tmp=1;
int p1,q1;
int maxx=0;
void visit(int p,int q){
    if(tmp==1){
        p1=p;
        q1=q;
    }
    if(save[p][q]>0){
        tmp+=save[p][q]-1;
        if(tmp>save[p1][q1])save[p1][q1]=tmp;
        if(tmp>maxx)maxx=tmp;
        tmp-=save[p][q]-1;
        return;
    }
    if(arr[p][q]<=arr[p][q-1] && arr[p][q]<=arr[p][q+1] && arr[p][q]<=arr[p-1][q] && arr[p][q]<=arr[p+1][q]){
        if(tmp>save[p1][q1])save[p1][q1]=tmp;
        if(tmp>maxx)maxx=tmp;
        return;
    }
    if(arr[p-1][q]<arr[p][q]){
        tmp++;
        visit(p-1,q);
        tmp--;
    }
    if(arr[p+1][q]<arr[p][q]){
        tmp++;
        visit(p+1,q);
        tmp--;
    }
    if(arr[p][q-1]<arr[p][q]){
        tmp++;
        visit(p,q-1);
        tmp--;
    }
    if(arr[p][q+1]<arr[p][q]){
        tmp++;
        visit(p,q+1);
        tmp--;
    }
}
int main(){
    int R,C;
    cin>>R>>C;
    for(int i=0;i<105;++i){
        for(int j=0;j<105;++j){
            arr[i][j]=MAX;
        }
    }
    for(int i=1;i<=R;++i){
        for(int j=1;j<=C;++j){
            cin>>arr[i][j];
        }
    }
    for(int i=1;i<=R;++i){
        for(int j=1;j<=C;++j){
            tmp=1;
            visit(i,j);
        }
    }
    cout<<maxx;
    return 0;
}
