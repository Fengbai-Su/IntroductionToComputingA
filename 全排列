/**********
描述
给定一个由不同的小写字母组成的字符串，输出这个字符串的所有全排列。 

我们假设对于小写字母有'a' < 'b' < ... < 'y' < 'z'，而且给定的字符串中的字母已经按照从小到大的顺序排列。
关于输入
输入只有一行，是一个由不同的小写字母组成的字符串，已知字符串的长度在1到6之间。
关于输出
输出这个字符串的所有排列方式，每行一个排列。要求字母序比较小的排列在前面。字母序如下定义： 

已知S = s1s2...sk , T = t1t2...tk，则S < T 等价于，存在p (1 <= p <= k)，使得 
s1 = t1, s2 = t2, ..., sp - 1 = tp - 1, sp < tp成立。
例子输入
abc
例子输出
abc

acb

bac

bca

cab

cba
提示
请严格用C语言实现。
***********/
#include <iostream>
#include <iomanip>
#include <cmath>
#include <cstring>
#include <algorithm>
using namespace std;
char str[10];
char tar[1000][10];
int cnt=0;
void swap(char *a,char *b){
    *a^=*b;
    *b^=*a;
    *a^=*b;
}
int rankk(int p,int len){
    if(p==len-1){
        strcpy(tar[cnt++],str);
    }
    for(int i=p;i<len;++i){
        if(str[i]==str[p] && i!=p)continue;
        swap(str[i],str[p]);
        rankk(p+1,len);
        swap(str[i],str[p]);
    }
    return 0;
}
int main(){
    cin>>str;
    int len=strlen(str);
    rankk(0,len);
    for(int i=0;i<cnt;++i){
        for(int j=i+1;j<cnt;++j){
            if(strcmp(tar[i],tar[j])>0){
                char tmp[10];
                strcpy(tmp,tar[i]);
                strcpy(tar[i],tar[j]);
                strcpy(tar[j],tmp);
            }
        }
    }
    for(int i=0;i<cnt;++i){
        cout<<tar[i]<<endl;
    }
    return 0;
}
