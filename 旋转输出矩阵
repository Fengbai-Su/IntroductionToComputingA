/*************
描述
给定一个N*N的矩阵，假设从左上角开始，旋转着依次输出矩阵中的每个元素，那么，一个5*5的矩阵，会按照下面的顺序输出。 
 
当然，这是个作业题。现在要求更进一步，假设根据上述方案，我们需要从开头（左上角）和结尾（中心，也就是原来的顺序中最后一个数）按照一正一反的顺序依次输出矩阵中的元素。也就是说，5*5的矩阵，会按照下面的顺序输出 
 
给定你该矩阵，请按照上述方式输出矩阵中的每个元素
关于输入
第一行一个数N 
接下来N行，每行N个数（用空格分隔），描述了该N*N的矩阵 
数据范围：1<=N<=100 
关于输出
一行，N*N个数，用空格分隔。按照上述顺序输出的矩阵的每个元素
例子输入
4
1 2 3 4
5 6 7 8
9 10 11 12
13 14 15 16
例子输出
1 10 2 11 3 7 4 6 8 5 12 9 16 13 15 14
***********/
#include <iostream>
#include <cstring>
#include <cmath>
#include <algorithm>
#include <cstdio>
#include <iomanip>
#define MAX 2147483647
using namespace std;
int main(){
    int N;
    cin>>N;
    int arr[105][105]={0};
    for(int i=0;i<N;++i){
        for(int j=0;j<N;++j){
            cin>>arr[i][j];
        }
    }
    int tar[10005]={0};
    int l=0,j=0,k=0;
    for(int i=0;i<N;++i){
        tar[i]=arr[0][i];
    }
    l=N;
    j=0;
    k=N-1;
    int cnt=N-1;
    int time=0;
    if(N==1){
        cout<<arr[0][0];
        return 0;
    }
    while(cnt){
        if(time%4==0){
            for(int i=0;i<cnt;++i){
                tar[l++]=arr[++j][k];
            }
            time++;
        }
        if(time%2==0)cnt--;
        if(cnt==0)break;
        if(time%4==1){
            for(int i=0;i<cnt;++i){
                tar[l++]=arr[j][--k];
            }
            time++;
        }
        if(time%2==0)cnt--;
        if(cnt==0)break;
        if(time%4==2){
            for(int i=0;i<cnt;++i){
                tar[l++]=arr[--j][k];
            }
            time++;
        }
        if(time%2==0)cnt--;
        if(cnt==0)break;
        if(time%4==3){
            for(int i=0;i<cnt;++i){
                tar[l++]=arr[j][++k];
            }
            time++;
        }
        if(time%2==0)cnt--;
    }
    cout<<tar[0]<<' '<<tar[l-1];
    time=0;
    j=1;
    for(int i=1;i<=l-2;++i){
        if(time==0){
            cout<<' '<<tar[j];
            time++;
        }else{
            cout<<' '<<tar[N*N-j-1];
            time=0;
            j++;
        }
    }
    return 0;
}
