/***********
来源	2790
描述
一天Extense在森林里探险的时候不小心走入了一个迷宫，迷宫可以看成是由n * n的格点组成，每个格点只有2种状态，.和#，前者表示可以通行后者表示不能通行。同时当Extense处在某个格点时，他只能移动到东南西北(或者说上下左右)四个方向之一的相邻格点上，Extense想要从点A走到点B，问在不走出迷宫的情况下能不能办到。如果起点或者终点有一个不能通行(为#)，则看成无法办到。
关于输入
第1行是测试数据的组数k，后面跟着k组输入。每组测试数据的第1行是一个正整数n (1 <= n <= 100)，表示迷宫的规模是n * n的。接下来是一个n * n的矩阵，矩阵中的元素为.或者#。再接下来一行是4个整数ha, la, hb, lb，描述A处在第ha行, 第la列，B处在第hb行, 第lb列。注意到ha, la, hb, lb全部是从0开始计数的。
关于输出
k行，每行输出对应一个输入。能办到则输出“YES”，否则输出“NO”。
例子输入
2

3

.##

..#

#..

0 0 2 2

5

.....

###.#

..#..

###..

...#.

0 0 4 0
例子输出
YES

NO
**********/
#include <iostream>
#include <iomanip>
#include <cmath>
#include <cstring>
#include <algorithm>
using namespace std;
int cnt=0;
int a,b,c,d,n;
bool flag[105][105]={0};
char str[105][105]={'\0'};
int visit(int p,int q){
    flag[p][q]=true;
    if(p==c && q==d){
        cnt++;
        return 0;
    }
    if(!cnt){
        if(p>0 && flag[p-1][q]==false && str[p-1][q]=='.')visit(p-1,q);
        if(p<n-1 && flag[p+1][q]==false && str[p+1][q]=='.')visit(p+1,q);
        if(q>0 && flag[p][q-1]==false && str[p][q-1]=='.')visit(p,q-1);
        if(q<n-1 && flag[p][q+1]==false && str[p][q+1]=='.')visit(p,q+1);
    }
    return 0;
}
int main(){
    int k;
    cin>>k;
    for(int i=0;i<k;++i){
        cin>>n;
        for(int i=0;i<n;++i){
            for(int j=0;j<n;++j){
                cin>>str[i][j];
            }
        }
        memset(flag,0,sizeof(flag));
        cin>>a>>b>>c>>d;
        cnt=0;
        if(str[c][d]=='#' || str[a][b]=='#'){
            cout<<"NO"<<endl;
            continue;
        }
        visit(a,b);
        if(cnt)cout<<"YES"<<endl;
        else cout<<"NO"<<endl;
    }
    return 0;
}
