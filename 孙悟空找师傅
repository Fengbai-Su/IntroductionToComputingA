/************
描述
“大师兄，师傅又被妖怪抓走了！”，沙师弟说道。悟空听到这个消息，便立刻前去救师傅。可是当悟空来到妖怪洞府时，发现妖怪给自己设了一个阵，只有成功破解这个阵，悟空才能救出师傅。请帮悟空判断他能否救出师傅。 
关于输入
输入第一行是两个数字m和n，表示该阵为m*n大小（0 < m,n <= 50，m为行，n为列）。接下来是一个m*n的矩阵表示这个阵。其中0为该阵中可走的路，1为墙（即不能走的位置），2为悟空的位置，3为师傅的位置。悟空只有四个可行的行走方向：即，上、下、左、右，不能斜对角线穿越。每行输入的数据之间都是空格间隔。 
关于输出
输出只有一行，"Yes"或"No"表示悟空是否可以成功救出师傅（悟空能走到师傅的位置即可救出师傅）。
例子输入
8 7

1 1 1 1 1 1 3

1 0 0 0 0 0 0

1 0 1 1 1 1 1

1 0 0 0 1 1 1

1 1 1 0 0 0 1

1 0 0 0 1 0 1

1 0 1 1 1 0 1

2 0 1 1 1 0 0

例子输出
Yes
**********/
#include <iostream>
#include <iomanip>
#include <cmath>
#include <cstring>
#include <algorithm>
using namespace std;
bool flag[55][55]={0};
int arr[55][55];
int m,n,tar=0;
int visit(int p,int q){
    flag[p][q]=true;
    if(arr[p][q]==3){
        tar=1;
        return 1;
    }
    if(p<m-1 && (arr[p+1][q]==0 || arr[p+1][q]==3) && flag[p+1][q]==false && tar!=1)visit(p+1,q);
    if(p>0 && (arr[p-1][q]==0 || arr[p-1][q]==3) && flag[p-1][q]==false && tar!=1)visit(p-1,q);
    if(q>0 && (arr[p][q-1]==0 || arr[p][q-1]==3) && flag[p][q-1]==false && tar!=1)visit(p,q-1);
    if(q<n-1 && (arr[p][q+1]==0 || arr[p][q+1]==3) && flag[p][q+1]==false && tar!=1)visit(p,q+1);
    if(tar==1)return 1;
    else return 0;
}
int main(){
    cin>>m>>n;
    int a,b;
    memset(arr,-1,sizeof(arr));
    for(int i=0;i<m;++i){
        for(int j=0;j<n;++j){
            cin>>arr[i][j];
            if(arr[i][j]==2){
                a=i;
                b=j;
            }
        }
    }
    if(visit(a,b)==1)cout<<"Yes";
    else cout<<"No";
    return 0;
}
