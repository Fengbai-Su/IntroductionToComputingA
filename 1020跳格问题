/***************
描述
有一种游戏，在纸上画有很多小方格，第一个方格为起点(S)，最后一个方格为终点。有一个棋子，初始位置在起点上，棋子每次可移动一次，棋子在起点时，可向前移动一个格子到第二个方格内；棋子在其他方格内时，可根据方格内的数字Ni进行移动。如果Ni大于零，就向前移动Ni个格子；如果Ni小于零，就向后移动-Ni个格子；如果Ni等于零，则此次原地不动一次，在下一步移动时可向前移动一步到下一个格子。显然，如果仅按此方案，会出现棋子永远移动不到终点的情形。为防止这种情况发生，我们规定，当棋子再次来到它曾经到过的方格时，它需要原地不动一次，在下一步移动时可向前移动一步到下一个格子。按此方案，棋子总能够走到终点(F)。如果给定一个方格图，试求棋子要走多少步才能从起点走到终点。（注：当然还可能会出现向前移动Ni个格子就跑过终点了，则把棋子放到终点上。如果Ni太小，使得棋子向后移动跑过了起点，则把棋子放到起点上。）（如图所示，其中S代表起点，F代表终点）（只有离开后再次来到一个方格时，才算来到它曾经到过的方格，包括起点S） 

关于输入
第一行为所有中间格子的总数n（n<20）（即加上起点小格子和终点小格子，共有n+2个小格子）。 
其余各行上分别为一个整数，表示对应的小格子上的初始数字。
关于输出
输出一行，要从起点跳到终点，共要跳多少步。 
（注：每跳一步，可能跳过多个格子，也可能原地不动。)
例子输入
5

2

3

-2

0

-5


例子输出
19
提示
只有离开后再次来到一个方格时，才算来到它曾经到过的方格，包括起点S 
如果有疑问可再读一遍题干！
**************/
#include <iostream>
#include <cstring>
#include <cmath>
#include <algorithm>
#include <cstdio>
#include <iomanip>
#define MAX 2147483647
using namespace std;
int main(){
    int n;
    cin>>n;
    int arr[25]={0};
    bool flag[25]={0};
    flag[0]=true;
    for(int i=1;i<=n;++i){
        cin>>arr[i];
    }
    int cnt=1;
    int p=1;
    int time=0;
    while(true){
        cnt++;
        if(flag[p]==false){
            flag[p]=true;
            if(arr[p]!=0){
                p+=arr[p];
            }else if(arr[p]==0 && time==0){
                time++;
                continue;
            }else if(arr[p]==0 && time==1){
                time=0;
                p++;
            }
            if(p<0)p=0;
            if(p>=n+1)break;
        }else if(flag[p]==true && time==0){
            time++;
            continue;
        }else if(flag[p]==true && time==1){
            p++;
            time=0;
            if(p>=n+1)break;
        }
        if(p>=n+1)break;
    }
    cout<<cnt;
    return 0;
}
